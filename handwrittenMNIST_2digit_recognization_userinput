import cv2
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models

# -----------------------------
# 1. Load & Train CNN on MNIST
# -----------------------------
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()

# Preprocess: reshape and normalize to [0,1]
x_train = x_train.reshape(-1, 28, 28, 1).astype("float32") / 255.0
x_test  = x_test.reshape(-1, 28, 28, 1).astype("float32") / 255.0

model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation="relu", input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation="relu"),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation="relu"),
    layers.Dense(10, activation="softmax")  # digits 0â€“9
])

model.compile(
    optimizer="adam",
    loss="sparse_categorical_crossentropy",
    metrics=["accuracy"]
)

print("Training MNIST model...")
model.fit(
    x_train, y_train,
    epochs=3,          # increase if you want better accuracy
    batch_size=64,
    validation_data=(x_test, y_test),
    verbose=1
)

# -----------------------------
# 2. Helper: preprocess single digit image
# -----------------------------
def preprocess_digit(img_digit):
    # Resize to 28x28
    img_resized = cv2.resize(img_digit, (28, 28))

    # If background is white, invert (MNIST is black digit on white bg)
    if np.mean(img_resized) > 127:
        img_resized = 255 - img_resized

    # Normalize to [0,1]
    img_norm = img_resized.astype("float32") / 255.0

    # Shape to (1, 28, 28, 1) for CNN
    img_input = img_norm.reshape(1, 28, 28, 1)
    return img_input

# -----------------------------
# 3. Load 2-digit image
# -----------------------------
img_path = input("Enter path to your 2-digit image (e.g. two_digits.png): ").strip()

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
if img is None:
    print("Error: could not read image. Check the path.")
    raise SystemExit

h, w = img.shape

# -----------------------------
# 4. Split image into left & right halves
# -----------------------------
mid = w // 2
left_img  = img[:, :mid]
right_img = img[:, mid:]

# (Optional) Show the split digits
plt.figure(figsize=(6, 3))
plt.subplot(1, 2, 1)
plt.imshow(left_img, cmap="gray")
plt.title("Left digit")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(right_img, cmap="gray")
plt.title("Right digit")
plt.axis("off")
plt.tight_layout()
plt.show()

# -----------------------------
# 5. Preprocess & predict each digit
# -----------------------------
left_input  = preprocess_digit(left_img)
right_input = preprocess_digit(right_img)

pred_left  = model.predict(left_input, verbose=0)
pred_right = model.predict(right_input, verbose=0)

left_digit  = int(tf.argmax(pred_left, axis=1).numpy()[0])
right_digit = int(tf.argmax(pred_right, axis=1).numpy()[0])

# -----------------------------
# 6. Print final result
# -----------------------------
print("Predicted LEFT digit :", left_digit)
print("Predicted RIGHT digit:", right_digit)
print("Predicted 2-digit number:", f"{left_digit}{right_digit}")
